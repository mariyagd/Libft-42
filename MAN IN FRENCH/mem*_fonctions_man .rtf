{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\fmodern\fcharset0 Courier-Bold;\f1\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;\red32\green166\blue3;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c11306\c69375\c172;\cssrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1133\margr1133\margb1133\margt1133\vieww11800\viewh16940\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\b\fs24 \cf2 \expnd0\expndtw0\kerning0
void *memcpy(void *restrict dst, const void *restrict src, size_t n);\
\pard\pardeftab720\partightenfactor0

\f1\b0 \cf2 \
\pard\pardeftab720\partightenfactor0
\cf3 Copie n octets de l\'92adresse m\'e9moire src vers l\'92adresse m\'e9moire dst. Si dst et src se chevauchent, le comportement est ind\'e9fini. Dans ce cas c\'92est mieux d\'92utiliser la fonction memmove.\
\
La fonction retourne la valeur originale de dst.\
\
Si dst \ul \ulc3 ou\ulnone  src est un pointeur NULL ((void*)0), le compilateur affiche seg fault.\
\
Si dst \ul et\ulnone  src sont NULL ((void*)0), le compilateur affiche (null). \
\pard\pardeftab720\partightenfactor0
\cf2 \
\
\pard\pardeftab720\partightenfactor0

\f0\b \cf2 void	*memccpy(void *dst, const void *src, int c, size_t n);\
\pard\pardeftab720\partightenfactor0

\f1\b0 \cf3 \
Copie n octets, transform\'e9s en unsigned char, de la src vers dst.\
La copie s\'92arr\'eate lorsque le i\'e8me \'e9l\'e9ment de src est \'e9gal \'e0 c (transform\'e9 en unsigned char). La fonction retourne le pointeur dst.\
\
Si un caract\'e8re c n\'92a pas \'e9t\'e9 trouv\'e9, un pointeur NULL est renvoy\'e9.\
\
Si dst ou src, ou les deux, sont des pointeurs NULL ((void)*0), le compilateur affiche seg fault.\
\
 \
\pard\pardeftab720\partightenfactor0

\f0\b \cf2 void *memmove(void *dst, const void *src, size_t len)\
\pard\pardeftab720\partightenfactor0

\f1\b0 \cf3 \
Copie len octets de la cha\'eene src vers la cha\'eene dst. Les deux cha\'eenes peuvent se chevaucher mais la copie n\'92est pas destructrice.\
La fonction retourne la valeur originale de dst.\
\
Si dst \ul ou\ulnone  src est un pointeur NULL ((void*)0), le compilateur affiche seg fault.\
\
Si dst \ul et\ulnone  src sont NULL ((void*)0), le compilateur affiche (null). \
\
\
\pard\pardeftab720\partightenfactor0

\f0\b \cf2 void *memchr(const void *s, int c, size_t n);\
\pard\pardeftab720\partightenfactor0

\f1\b0 \cf3 \
La fonction recherche la location de la premi\'e8re occurrence de c (converti en unsigned char) dans n octets de la cha\'eene s.\
\
La fonction retourne un pointeur vers l\'92octet de cette localisation.\
\
Si l\'92octet c n\'92existe pas, la fonction retourne un pointeur NULL et compilateur affiche (null).\
\
Si s est ((void*)0), le compilateur affiche seg fault.\
\
\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f0\b \cf2 int memcmp(const void *s1, const void *s2, size_t n);\
\pard\pardeftab720\sl360\sa240\partightenfactor0

\f1\b0 \cf3 La fonction compare les octets de la cha\'eene s1 avec les octets de la cha\'eene s2.\
Les deux cha\'eenes ont n octets.\
La fonction retourne z\'e9ro si les deux cha\'eenes sont identiques. Sinon retourne la diff\'e9rence entre les deux premiers octets qui sont diff\'e9rents.\
\pard\pardeftab720\partightenfactor0
\cf3 Si dst ou src, ou les deux, sont des pointeurs NULL ((void)*0), le compilateur affiche seg fault.\
\pard\pardeftab720\sl360\sa240\partightenfactor0
\cf3 \
Si s1 et s2 sont des cha\'eenes \'e0 taille z\'e9ro, c\'92est-\'e0-dire s1= ""\'a0 et s2 = "" , la fonction retourne 0 pour n\'92importe quelle n -> les fonctions sont identiques.\
}